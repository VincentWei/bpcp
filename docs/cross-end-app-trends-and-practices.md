# 跨端应用的趋势及实践

魏永明  
2022-11

		
## 应用赖以运行的计算环境正在发生深刻变化

1.  计算功能向云端或者边缘服务器集中，如语音交互等基于人工智能的服务。
1.  应用需要借助云计算或者边缘计算与各种联网设备进行数据交换，比如在车载座舱中。
1.  应用需要通过各种设备和手段与用户交互：
   - 设备：桌面、手机、车载座舱、手表、电视……
   - 手段：键盘、鼠标、触摸、语音、手势……

		
## 应对计算环境的变化

1.  厂商为不同的设备开发不同的操作系统，开发者为不同的操作系统开发各自的版本：
   - Office 应用在 Windows 和 macOS 上有不同的版本。
   - WPS 应用在 iOS 和 Android 上有不同的版本。
1.  在同一种应用框架的支持下，让处于中心位置的应用功能外溢到其他设备：
   - iOS 应用的部分功能外溢到 watchOS 上。
   - 通过 CarPlay 功能将智能手机应用的功能外溢到车载座舱中。

		
## 围绕特定操作系统建立独立应用生态的条件

魏森特公式：  
应用生态指数 = 典型用户交互时长（小时/每天） * 人群占比（0 ~ 100）

1.  当生态指数越大，建立独立生态的意义和价值越大。
1.  当生态指数越小，建立独立生态的意义和价值越小。
1.  计算典型设备的应用生态指数：
   - 智能手机：2 * 80 = 160
   - 桌面电脑：6 * 20 = 120
   - 智能电视：0.5 * 50 = 25
   - AR/VR 设备：0.5 * 20 = 10
   - 智能手表：0.1 * 50 = 5
1.  当应用生态指数大于 60 时，才有创建独立应用生态的意义和价值
1.  应用生态的指数越高，竞争越激烈，越能表现出赢者通吃的特点
1.  为除了桌面和手机之外的周边设备创建独立应用生态会非常困难

		
## 智能汽车的应用生态指数几何？

1. 典型用户交互时长：0.5 到 1
1. 人群占比：60（中国 15-59 岁人口占比）
1. 车载应用的生态指数为：30 到 60。

结论：如同鸡肋，两难

1.  建：投入大、产出小
1.  不建：沦为其他应用生态的附庸

		
难道我们就没有别的办法了吗？

		
## 透过现象看本质

跨端运行是未来应用的最重要特征

1.  小程序、CarPlay 等代表的最重要的应用形态：跨端运行
   - 小程序不光可以在手机上运行，也可以在桌面上运行。
   - 智能手机中的应用可以同时在车载屏幕上和用户交互。
   - 智能手机中的应用可以同时运行在智能手表上。
   - 某国产厂商提出的多场景协同。
1. 但目前的技术并不是真正的跨端运行：
   - 限定在特定的操作系统平台（苹果系）或者软件运行环境（微信）中。
   - 前者在不同的操作系统有不同的实现，连跨操作系统都未能实现。
   - 后者只支持桌面和手机两种设备。

		
## 跨端应用（cross-end app）的终极表现

1. 支持异构设备及异构操作系统
1. 一次开发，多端运行，跨端协同
1. 多场景协同，分布式部署及运行

		
## 我们的实践：HVML 及其应用框架

- HVML 是 `Hybrid Virtual Markup Language` 的缩写，中文名：“呼噜猫”。
- HVML 读作 /'huːmeil/，音似普通话读“虎妹儿”。
- HVML 不同于常见的高级编程语言（C/C++/Java/Rust），也不同于常见的脚本语言（JavaScript/PHP/Python 等）。
- HVML 是一种可编程标记语言，也是一种描述式编程语言。
- HVML 程序的输出包括：传统的流、文件、数据库以及目标文档。
- HVML 程序的输入包括：传统的流、文件、数据库以及各种事件。

	
### HVML 应用框架的特征

1. 解耦程序的运行逻辑和渲染细节，开发者不需要使用 C/C++ 语言来操控界面以及交互细节，从而解放生产力。
1. HVML 充当系统模块和界面交互之间的粘合剂，从而解耦原生模块（C/C++模块）和业务逻辑（HVML），可构建具有现代特征的应用框架，从而提升整个项目的管理水平和工程维护能力。
1. HVML 使用描述式语法，减低入门门槛的同时，极大提高开发效率。
1. 使用业界公认的规范和标准（HTML、CSS 等），方便开发者学习和掌握。
1. 由于大量复用了成熟的 Web 前端技术，人才市场上拥有丰富的开发者人才储备。
1. HVML 应用框架支持跨端运行，这为将来的多场景协同提供了最佳支持。

	
### 灵活的 HVML 应用框架：渲染器作为服务器

![渲染器作为服务器](assets/renderer-as-server.svg)

	
### 灵活的 HVML 应用框架：渲染器作为数据总线端点

![渲染器作为数据总线端点](assets/renderer-as-data-bus-endpoint.svg)

	
### 灵活的 HVML 应用框架：渲染器作为独立线程

![渲染器作为独立线程](assets/renderer-as-thread.svg)

	
### 灵活的 HVML 应用框架：渲染器作为客户端

![渲染器作为客户端](assets/renderer-as-client.svg)

	
### 灵活的 HVML 应用框架：无头渲染器

![无头渲染器](assets/renderer-headless.svg)

		
## 意见或建议

